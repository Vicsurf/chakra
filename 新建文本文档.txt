#include<reg52.h>
#include"intrins.h"
#define uchar unsigned char
#define uint unsigned int

sbit ZQ=P1^5;
sbit ZH=P1^4;
sbit YQ=P1^2;
sbit YH=P1^1;
sbit ENA=P1^0;
sbit ENB=P1^6;

uchar time1=0,pwm1=0,time2=0,pwm2=0;



void qianjin()
{
   	ZQ=1;
	ZH=0;
	YQ=1;
	YH=0;
	pwm1=20;
	pwm2=20;
}
void zuozhuan1()
{
	ZQ=0;
	ZH=1;
	YQ=1;
	YH=0;
	pwm1=10;
	pwm2=15;

}

 void youzhuan1()
{
	ZQ=1;
	ZH=0;
	YQ=0;
	YH=1;
	pwm1=15;
	pwm2=10;
}




void init()
{
 TMOD=0x01;
 EA=1;
 ET0=1;
 TR0=1;
 TH0=(65535-10)/256;
 TL0=(65535-10)%256;
}

void time0() interrupt 1
{
 time1++;
 if(time1<pwm1)
 	{
	 ENA=1;
	}
 else
 	{
	 ENA=0;
	}
 if(time1>20)
 	{
 	 time1=0;
 	}

 time2++;
 if(time2<pwm2)
 	{
	 ENB=1;
	}
 else
 	{
	 ENB=0;
	}
 if(time2>20)
 	{
 	 time2=0;
 	}

}

void main()
{	init();
qianjin();
}


//
#include <reg52.h>   
#define uchar unsigned char 
sbit beep=P3^6;
uchar timer0h,timer0l,time;

code uchar sszymmh[]={6,2,3,5,2,1,3,2,2,5,2,2,1,3,2,6,2,1,5,2,1,
                      6,2,4,3,2,2,5,2,1,6,2,1,5,2,2,3,2,2,1,2,1,
                      6,1,1,5,2,1,3,2,1,2,2,4,2,2,3,3,2,1,5,2,2,
                      5,2,1,6,2,1,3,2,2,2,2,2,1,2,4,5,2,3,3,2,1,
                      2,2,1,1,2,1,6,1,1,1,2,1,5,1,6,0,0,0 
                                      };

code uchar FREQH[]={0xF2,0xF3,0xF5,0xF5,0xF6,0xF7,0xF8, 
                    0xF9,0xF9,0xFA,0xFA,0xFB,0xFB,0xFC,0xFC, //1,2,3,4,5,6,7,8,i
                    0xFC,0xFD,0xFD,0xFD,0xFD,0xFE,
                    0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFF,} ;

code uchar FREQL[]={0x42,0xC1,0x17,0xB6,0xD0,0xD1,0xB6,
                    0x21,0xE1,0x8C,0xD8,0x68,0xE9,0x5B,0x8F, //1,2,3,4,5,6,7,8,i
                    0xEE,0x44, 0x6B,0xB4,0xF4,0x2D, 
                    0x47,0x77,0xA2,0xB6,0xDA,0xFA,0x16,};
void delay(uchar t)	 
{
	uchar t1;
	unsigned long t2;
	for(t1=0;t1<t;t1++)
	{
		for(t2=0;t2<8000;t2++);
	}
	TR0=0;
}
void song()	
{
	TH0=timer0h;
	TL0=timer0l;
	TR0=1;
	delay(time);                       
}


void main(void)
{
	uchar k,i;
	TMOD=1; 
	EA=1;
	ET0=1;
	while(1)
	{
		i=0;  
		while(i<100)		
		{              
			k=sszymmh[i]+7*sszymmh[i+1]-1;
			timer0h=FREQH[k];
			timer0l=FREQL[k];
			time=sszymmh[i+2];
			i=i+3;
			song();
		}
	} 
}
void t0int() interrupt 1	
{
	TR0=0;
	beep=!beep;
	TH0=timer0h;
	TL0=timer0l;
	TR0=1;
}
//世上只有妈妈好

//隔离-----------------------------------

void  StartModule()            //启动模块
  {
   TX=1;                        //启动一次模块
   _nop_();  _nop_(); _nop_(); _nop_(); _nop_(); 
   _nop_(); _nop_(); _nop_(); _nop_(); _nop_(); 
   _nop_(); _nop_(); _nop_(); _nop_(); _nop_(); 
   _nop_(); _nop_();_nop_(); _nop_(); _nop_(); 
   _nop_();
   TX=0;
  }

  void Conut(void)
{
  time=TH0*256+TL0;
  TH0=0;
  TL0=0;
 
  S=(time*1.7)/100;     //算出来是CM
  if((S>=700)||flag==1) //超出测量范围显示“-”
  {  
    flag=0;
    DisplayOneChar(0, 1, ASCII[11]);
    DisplayOneChar(1, 1, ASCII[10]); //显示点
    DisplayOneChar(2, 1, ASCII[11]);
    DisplayOneChar(3, 1, ASCII[11]);
    DisplayOneChar(4, 1, ASCII[12]); //显示M
  }
  else
  {
    disbuff[0]=S%1000/100;
    disbuff[1]=S%1000%100/10;
    disbuff[2]=S%1000%10 %10;
    DisplayOneChar(0, 1, ASCII[disbuff[0]]);
    DisplayOneChar(1, 1, ASCII[10]); //显示点
    DisplayOneChar(2, 1, ASCII[disbuff[1]]);
    DisplayOneChar(3, 1, ASCII[disbuff[2]]);
    DisplayOneChar(4, 1, ASCII[12]); //显示M
  }
}

void main(void)
{
 unsigned char TempCyc;
 Delay400Ms(); //启动等待，等LCM讲入工作状态
 LCMInit(); //LCM初始化
 Delay5Ms(); //延时片刻(可不要)
 DisplayListChar(0, 0, mcustudio);
 DisplayListChar(0, 1, email);
 ReadDataLCM();//测试用句无意义
 for (TempCyc=0; TempCyc<10; TempCyc++)
 Delay400Ms(); //延时
 DisplayListChar(0, 1, Cls); 
 while(1)
 {
   TMOD=0x01;     //设T0为方式1，GATE=1；
   TH0=0;
   TL0=0;          
   ET0=1;             //允许T0中断
   EA=1;      //开启总中断   
  while(1)
    {
       StartModule();
   // DisplayOneChar(0, 1, ASCII[0]);
       while(!RX);  //当RX为零时等待
      TR0=1;       //开启计数
       while(RX);   //当RX为1计数并等待
       TR0=0;    //关闭计数
          Conut();   //计算
          delayms(80);  //80MS 
     }
 }
}